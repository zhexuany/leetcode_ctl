package main

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type LeetcodeProblem struct {
	FrequencyMid    int    `json:"frequency_mid"`
	NumSolved       int    `json:"num_solved"`
	CategorySlug    string `json:"category_slug"`
	StatStatusPairs []struct {
		Status interface{} `json:"status"`
		Stat   struct {
			TotalAcs            int         `json:"total_acs"`
			QuestionTitle       string      `json:"question__title"`
			QuestionArticleSlug interface{} `json:"question__article__slug"`
			TotalSubmitted      int         `json:"total_submitted"`
			QuestionTitleSlug   string      `json:"question__title_slug"`
			QuestionArticleLive interface{} `json:"question__article__live"`
			QuestionHide        bool        `json:"question__hide"`
			QuestionID          int         `json:"question_id"`
		} `json:"stat"`
		IsFavor    bool `json:"is_favor"`
		PaidOnly   bool `json:"paid_only"`
		Difficulty struct {
			Level int `json:"level"`
		} `json:"difficulty"`
		Frequency int `json:"frequency"`
		Progress  int `json:"progress"`
	} `json:"stat_status_pairs"`
	IsPaid        bool   `json:"is_paid"`
	FrequencyHigh int    `json:"frequency_high"`
	UserName      string `json:"user_name"`
	NumTotal      int    `json:"num_total"`
	ListNames     struct {
	} `json:"list_names"`
}

func getJsonFromLeetCode() LeetcodeProblem {

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	req, err := http.NewRequest("GET", "https://leetcode.com/api/problems/algorithms/", nil)
	if err != nil {
		// handle err
	}
	req.Header.Set("Cookie", "_gat=1; csrftoken=xKpOqsNQvNKCzhXyEwUVMhThfejftmsmUsbjvMTVOO0awGBRnrP0Ogvad2HSmXpj; _ga=GA1.2.1442407930.1481621879")
	req.Header.Set("Dnt", "1")
	// req.Header.Set("Accept-Encoding", "gzip, deflate, sdch, br")
	req.Header.Set("Accept-Language", "zh-CN,zh;q=0.8,zh-TW;q=0.6,ja;q=0.4,en;q=0.2")
	req.Header.Set("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.98 Safari/537.36")
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json, text/javascript, */*; q=0.01")
	req.Header.Set("Referer", "https://leetcode.com/problemset/algorithms/")
	req.Header.Set("X-Requested-With", "XMLHttpRequest")
	req.Header.Set("Connection", "keep-alive")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()

	// buf := bytes.NewBuffer(body)
	// reader, err := gzip.NewReader(buf)
	// if err != nil {
	// panic(err)
	// }

	// bytes.Replace(body, []byte{"\x1f"}, []byte{' '}, -1)
	// lp := make([]LeetcodeProblem, 0)
	lp := LeetcodeProblem{}

	err = json.NewDecoder(resp.Body).Decode(&lp)
	if err != nil {
		fmt.Printf("failed to decode json object %v", err)
	}
	return lp
}

func main() {
	Level := [3]string{"Easy", "Medium", "Hard"}
	ls := getJsonFromLeetCode()
	resStr := ""
	length := len(ls.StatStatusPairs)
	for i := length - 1; i >= 0; i-- {
		data := ls.StatStatusPairs[i]
		line := fmt.Sprintf(`"[%s] /problems/%s/" %d`, Level[data.Difficulty.Level-1], data.Stat.QuestionTitleSlug, data.Stat.QuestionID)
		resStr += line
		if i > 0 {
			resStr += "\n"
		}
		// resStr = resStr + "[" + Level[data.Difficulty.Level-1] + "] "
		// resStr = resStr + "/problems/" + data.Stat.QuestionTitleSlug
		// resStr = resStr + " " + strconv.Itoa(data.Stat.QuestionID)
		// if i < len(ls.StatStatusPairs) {
		// resStr += "\n"
		// }
	}

	fmt.Println(resStr)
}
